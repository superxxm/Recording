# Reg Fundamentals
## 目录
1. __字符组__
    1.1 __字符组的基本用法__
    1.2 __范围表示法(range)__
    1.3 __字符组简记(shorthands)__
    1.4 __元字符与转义__
    1.5 __排除型字符组(Negated Character Class)__
    1.6 __POSIX字符组__
2. __量词__
    2.1 __量词的一般形式__
    2.2 __常用量词__
    2.3 __点号__
    2.4 __匹配优先量词、忽略优先量词__
    2.5 __量词的转义__
3. __括号__
    3.1 __分组__
    3.2 __多选结构__
    3.3 __引用分组__
    3.4 __反向引用__
    3.5 __命名分组__
    3.6 __非捕获分组__
4. __断言__
    4.1 __单词边界__
    4.2 __行起始/结束位置__
    4.3 __环视__
5. __匹配模式__    
    5.1 __不区分大小写模式__
    5.2 __单行模式__
    5.3 __多行模式__
    5.4 __注释模式__
    5.5 __非贪婪__
    ...
## 1.字符组
> 字符组(Character Class) 就是一组字符，在正则中， 它表示“在同一位置可能出现的各种字符”。写法：[ab]、[123]、[#..!!]
### 1.1字符组的基本用法
`[...]`

```
preg_match('/[012345678]/', '5'); //=>1
preg_match('/[abc123]/', '5'); //=>0
```
### 1.2范围表示法(range)
`[x-y]`表示`x`到`y`整个范围的字符。如，`[0-9]`，`[a-z]`。
为什么是`[0-9]`而不是`[9-0]`呢
因为`-`表示的范围一般是根据字符对应的码值(Code Point)来确定的，典型的有ASCII编码，在ASCII 编码中，0-9的码值是48～57，a~z的码值是97～122，A~Z的码值是65～90。
```
preg_match('/[0-9]/', '5');  //=>1
preg_match('/[a-zA-Z]/', '5');  //=>0
preg_match('/[a-zA-Z]/', 'x');  //=>1
```
### 1.3字符组简记法(shorthands)
- `\d`所有数字，即`[0-9]`
- `\D`所有非数字与`\d`互斥
- `\w`所有单词字符(字符，数字，下划线)，即`[0-9a-zA-Z_]`
- `\W`所有非单词字符，与`\w`互斥
- `\s`所有空白字符，包括空格、制表符、回车符、等
- `\S`所有非空白字符
### 1.4元字符与转义
在范围表示法中，字符组中的横线`-`不能匹配横线字符，而是用来表示范围，这类字符叫做__元字符__（meta-character）。元字符除了`-`还有`[`,`]`,`^`,`$`等，它们都有特殊的意义，当元字符想表示普通字符的含义时，就需要转义处理(在元字符前加反斜线字符`\`)。对于`-`有一个例外情况，就是当它紧跟着字符组中的开括号`[`时，就表示普通横线字符，此时不用转义。
```
preg_match('/[0\-9]/', '-')  //=>1;
preg_match('/[0\-9]/', '8')  //=>0;
preg_match('/[-09]/', '-')  //=>1;
```
### 1.5排除型字符组(Negated Character Class)
在方括号`[...]`中列出希望匹配的所有字符叫做“普通字符组”。在开方括号`[`之后跟一个`^`，写作`[^...]`，表示“在当前位置匹配一个没有列出的字符”，例如`[^0-9]`匹配非数字
```
preg_match('/[^0-9]/', 'x');  //=>1
preg_match('/[^0-9]/', '1');  //=>0
```
`^`符号也是元字符，如果想要紧跟在开方括号之后表示取反。若想在方括号之后匹配字符`^`就需要转义
### 1.6POSIX字符组
之前介绍的字符组，都属于Perl衍生出来的正则表达式流派(Flavor),这个流派叫做PCRE(Per Compatible Regular Experssion)。正则表达式还有其他流派，比如POSIX(Portable Operating System Interface for unix)，它是一系列规范，定义了UNIX操作系统应当支持的功能，其中也包括了正则表达式的规范。
常见的`[a-z]`形式的字符组，在POSIX规范中仍然获得支持，称作__POSIX方括号表达式__。POSIX方括号表达式中的`\`不是用来转义的，如`[\d]`就只能匹配`\`和`d`两个字符，这里涉及到`]`,`-`两个特殊字符，在POSIX规范中，紧接在开方括号`[`之后的`]`才表示闭方括号，紧挨着闭方括号`]`之前的`-`才表示横线字符。
对于PCRE规范中的`\d`,`\w`,`\s`等字符组简记，POSIX中有类似的东西，叫做__POSIX字符组__。在ASCII语言环境(locale)中，常见的POSIX字符组及其含义如下:
|__POSIX字符组__|__说明__|__ASCII字符组__|__等价的PCRE简记法__|
|--------|--------|-----------|----|
|[:alnum:]|字母和数字|[0-9a-zA-Z]|    |
|[:alpha:]|字母    |[9-zA-Z]|    |
|[:ASCII:]|ASCII字符|[\x00-\x7F]|    |
|[:blank:]|空格字符和制表字符|[\t]|    |
|[:cntrl:]|控制字符|[\x00-\x1F\x7F]|    |
|[:digit:]|数字字符|[0-9]|\d    |
|[:graph:]|空白字符之外的字符|[\x21-\x7E]|    |
|[:lower:]|小写字母字符|[a-z]|    |
|[:print:]|类似[:graph:]，但是包括空白字符|[\x20-\x7E]|    |
|[:punct:]|标点符号|[!"#$%&'()*+,./:;<=>?@\^_`{\]|    |
|[:space:]|空白符号|[\t\r\n\v\f]|\s    |
|[:upper:]|大写字母|[A-Z]|\s    |
|[:word:]|字母字符|[a-zA-Z0-9_]|\w    |
|[:xdigit:]|十六进制字符|[A-Fa-f0-9]|    |
## 2. 量词
首先介绍一下`^`和`$`两个特殊字符。
`^`放在正则表达式的开头，表示“定位到字符串的起始位置”;`$`放在正则表达式的末尾，表示“定位到字符串的结束位置”。
```
preg_match('/^\w\d/', '1a3b');  //=>0开头必须为字母
preg_match('/\w\d$/', '1a3b');  //=>0必须以数字结尾
preg_match('/^\w\d$/', 'a3');  //=>1开头为字母，结尾为数字
```
### 2.1 量词的一般形式
量词的通用形式是`{m,n}`(`,`后不能有空格)，它限定之前的元素能够出现的次数，m是下限，n是上限，其他常见的量词形式有：
|__量词__|__说明__|
|-------|------|
|{n}    |之前的元素必须出现n次|
|{m,n}  |之前的元素最少出现m次，最多出现n次|
|{m,}   |之前的元素最少出现m次，无上限|
|{0,n}  |之前的元素可以不出现，也可以出现，最多出现n次|
### 2.2 常用量词
三个常用的量词，分别是`+`,`?`,`*`：
|__常用两次__|__{m,n}等价形式__|__说明__|
|-----------|---------------|-------|
|*|{0,}|可能出现，也可能不出现，没有上限|
|+|{1,}|至少出现一次，没有上限|
|?|{0,1}|出现0或1次|
```
preg_match('/^<[^>]+>$/', '<html>');  //=>1
preg_match('/^<[^>]+>$/', '<>');  //=>0
preg_match('/^https?$/', 'http')  //=>1;
preg_match('/^https?$/', 'https')  //=>1;
preg_match('/^\"[^\"]*\"$/', '""');  //=>1
preg_match('/^\"[^\"]*\"$/', '"dab"');  //=>1
```
### 2.3 点号
点号`.`是与量词搭配比较多的一个字符，一般情况下，点号`.`可以匹配除了换行符`\n`以外的任意字符
```
preg_match('/^.$/', 'z');  //=>1
preg_match('/^.$/', '8');  //=>1
preg_match('/^.$/', '\n');  //=>0
```
如果要是`.`能匹配的字符包含换行符`\n`,可以使用自制通配符`\s\S`或`\w\W`,`\d\D`
```
preg_match('/^[\s\S]$/', "\n");  //=>1
```
另一种方式是使用单行模式，在模式中介绍
### 2.4 匹配优先量词、忽略优先量词
很多语言中，都可以使用`/*...*/`来注释代码，如果是一个支持语法高亮的文本编辑器就要能够提取`/*...*/`注释块
```
$str = '/*comment*/ /*another comment*/'
preg_match('/\/\*.*\*\//', $str, $arr);
echo $arr[0];
/*comment*/ /*another comment*/
```
它将两个注释块都匹配出来了，如果两个注释块中间有代码，那么代码也会被匹配出来。这是因为，`*+?`都是__匹配优先量词__(greedy quantifier,也称贪婪量词)。匹配优先量词是指在拿不准是否要匹配的时候，优先尝试匹配。因此，两个注释块都被`.*`匹配了。
正则表达式中利用__忽略优先量词__来解决上述问题，与`*+?`对应的忽略优先量词的形式是`*?`,`+?`,`??`。
```
preg_match('/\/\*.*?\*\//', $str, $arr);
echo $arr[0];
/*comment*/
```
这样就可以提取注释块了。
|__匹配优先量词__|__忽略优先量词__|__限定次数__|
|--------------|--------------|----------|
|*             |*?            |可能出现，可能不出现没有上限|
|+             |+?            |至少出现1次，没有上限|
|?             |??            |出现0次或1次|
|{m,n}         |{m,n}?        |大于等于m，小于等于n|
|{m,}          |{m,}?         |至少出现m次，无上限|
|{0,n}         |{0,n}?        |出现0次-n次|
### 2.5 量词的转义
`*`,`+`,`?`的转义比较简单，就是`\*`,`\+`,`\?`。主要是`{m,n}`的转义。
|__量词__|__转义__|__量词__|__转义__|__量词__|__转义__|
|-------|-------|-------|-------|-------|--------|
|{n}    |\\{n}  |*      |\*     |*?     |\*\?   |
|{m,n}  |\\{m,n}|+      |\+     |+?     |\+\?   |
|{m,}   |\\{m,} |?      |\?     |??     |\?\?   |
|{0,n}  |\\{0,n}|
## 3. 括号
### 3.1 分组
量词可以控制它前面的字符或字符组的出现次数，如何控制一个单词出现或者不出现呢，需要用到__分组__(子表达式)，使用`(...)`实现分组。
```
// 量词限定前面一个字符
preg_match('/^hello?, world$/', 'hello, world');    // => 1
preg_match('/^hello?, world$/', 'hell, world');    // => 1
preg_match('/^hello?, world$/', ', world');    // => 0

// 量词限定一个单词
preg_match('/^(hello)?, world$/', 'hello, world');    // => 1
preg_match('/^(hello)?, world$/', 'hell, world');    // => 0
preg_match('/^(hello)?, world$/', ', world');    // => 1
```
### 3.2 多选结构
多选结构(alternative)的形式是`(...|...)`,在括号内以竖线`|`分开多个子表达式，这些子表达式叫做多选分支(option)。
例如，匹配常见的11位手机号码
```
// 匹配常见11位手机号
preg_match('/(13[0-9]|15[0-356]|18[025-9])\d{8}/', '18521510001', $arr);    // => 1
```
### 3.3 引用分组
正则表达式会保存每个`(...)`分组匹配的文本，即捕获分组(capturing group)。在需要直接使用子表达式的时候非常有用。
例如，提取`<a>`标签中的地址和描述文本
```
// 提取<a>标签中的地址和描述文本
preg_match('/<a\s+href="([^\'"\s]*)">(.*?)<\/a>/', '<a href="github.com">visit github</a>', $arr);
print_r($arr);
/*
Array
(
    [0] => <a href="github.com">github</a>
    [1] => github.com
    [2] => visit github
)
*/
```
正则表达式替换时也支持捕获分组。php中支持`\num`和`$num`的形式替换，但是num不能大于10；另一种形式${num}可以大于10。

例如，日期的替换
```
// 正则表达式替换
preg_replace('/(\d{4})-(\d{2})-(\d{2})/', '$1年$2月$3日', '2015-08-25');    // => 2015年08月25日
preg_replace('/(\d{4})-(\d{2})-(\d{2})/', '\1年\2月\3日', '2015-08-25');    // => 2015年08月25日

```
### 3.4 反向引用
在正则表达式内部引用之前的捕获分组匹配的文本叫反向引用(back-reference)。实测php支持`\num`形式的反向引用，不支持`$num`形式的反向引用
例如，利用反向引用匹配id相同的不同标签
```
//匹配id为main的标签
preg_match('/<([\w]+)\s+id="main">.*?<\/\1>/', '<div id="main"><span>hello, world</span></div>', $arr);
print_r($arr);
/*
Array
(
    [0] => <div id="main"><span>hello,world</span></div>
    [1] => div
)
*/
//匹配id为main的标签
preg_match('/<([\w]+)\s+id="main">.*?<\/\1>/', '<p id="main">Hello, World</p>', $arr);    // => 1
print_r($arr);
/*
Array
(
    [0] => <p id="main">Hello, World</p>
    [1] => p
)
*/
```
### 3.5 命名分组
数字编号的分组有时候不够直观，因此有些语言和工具的正则表达式提供了命名分组(named grouping)。
正则字符中`(?p<name>)`来命名，`(?p=<name>)`来使用。`preg_replace`时不支持
```
// 捕获命名分组
preg_match('/<a\s+href="(?P<link>[^\'"\s]*)">(?P<description>.*?)<\/a>/', '<a href="github.com">visit github</a>', $arr);
print_r($arr);                                                            
/*
Array
(
    [0] => <a href="github.com">visit github</a>
    [link] => github.com
    [1] => github.com
    [description] => visit github
    [2] => visit github
)
*/

// 反向引用命名分组
preg_match('/<(?P<tag>[\w]+)\s+id="main">.*?<\/(?P=tag)>/', '<div id="main"><span>hello, world</span></div>', $arr);
print_r($arr);                                                            
/*
Array
(
    [0] => <div id="main"><span>hello, world</span></div>
    [tag] => div
    [1] => div
)
*/
```
### 3.6 非捕获分组
正则表达式默认会保存每个`(...)`匹配的文本，但是，有时候正则表达式比较复杂，`(...)`会出现的比较多，而此时仅仅是想实现__分组__或者__多选__的功能，而不需要__捕获分组__;同时，大量不需要的捕获分组可能会影响性能。
就需要__非捕获分组__(non-capturing group)，它的形式是`(?:...)`。
```
// 捕获分组
preg_match('/(13[0-9]|15[0-356]|18[025-9])\d{8}/', '18521510001', $arr);    // => 1
print_r($arr);                                                            
/*
Array
(
    [0] => 18521510001
    [1] => 185
)
*/
// 非捕获分组
echo preg_match('/(?:13[0-9]|15[0-356]|18[025-9])\d{8}/', '18521510001', $arr);    // => 1
print_r($arr);                                                            
/*
Array
(
    [0] => 18521510001
)
*/
```
## 4. 断言
正则表达式中的有些结构不匹配真正的文本，只负责判断在某个位置左/右侧的文本是符合要求，这种结构成为__断言__(assertion)。常见的断言有三种：单词边界，行起/始位置，环视。
### 4.1 单词边界
即`\b`他匹配一个单词的边界位置。
### 4.2 行起始/结束位置
`^`：字符串开始位置
`$`：字符串结束位置
如果指定了多行模式，则分别匹配行的起始位置。
`\A`不论普通还是多行模式，都匹配字符串起始位置
`\Z`、`\z`不论普通还是多行模式，都匹配字符串结束位置
`\Z`和`\z`的区别在于最后字符串的末尾是__行终止符__的时候，`\Z`匹配行终止符之前的位置，`\z`则不管行终止符，只匹配“整个字符串的结束位置”。
这里用__行终止符__，而不用__换行符__是因为，不同操作系统的行终止符不同(windows`\r\n`,linux`\n`,mac`\n`)。

### 4.3 环视
环视(look-around)用来“停在原地，四处张望”，它本身也不匹配任何字符，用来限定它旁边的文本满足某种条件。
|__名字__|__记法__|__含义__|
|-------|--------|-------|
|肯定顺序环视|`(?=...)`|向右看看，右边出现了环视中的内容才匹配|
|否定顺序环视|`(?!...)`|向右看看，右边不出现环视中的内容才匹配|
|肯定逆序环视|`(?<=...)`|向右看看，左边出现环视中的内容才匹配|
|否定逆序环视|`(?<!...)`|向右看看，左边不出现环视中的内容才匹配|
## 5. 匹配模式    
### 5.1 不区分大小写模式
### 5.2 单行模式
### 5.3 多行模式
### 5.4 注释模式
### 5.5 非贪婪
    ...
